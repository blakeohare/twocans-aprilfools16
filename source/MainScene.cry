import Web;
import Math;
import GFX;


enum Mode {
	
	NONE,
	
	FALLS_DOWN, // T
	SHIVERS, // W
	BOMB_EXPLODES, // O
	DRAW_ON_SCREEN, // C
	RUNS_AROUND, // A
	PERSON_CHANGES, // N
	INVERT_COLORS, // S
	
	DONT_GET_BANNED, // S
	CREDITS, // T
	SCENERY, // R
	TODO_IMPLEMENT, // I
	TOTORO, // N
	BANNED, // G
}

enum LetterFallModes {
	FALLING_DOWN,
	HITTING_PLAYER,
	FALLING_BACK,
	BOTH_BACK,
}

const GROUND_Y = SCREEN_HEIGHT * 3 / 4;
const LETTERS_Y = SCREEN_HEIGHT / 3;

class MainScene : AbstractScene {
	field mode = Mode.NONE;
	field modeCounter = 0;
	field person = null;
	field letters = [];
	field sprites = null;
	field otherSprites = [];
	field activeLetter = null;
	field queuedMode = null;
	field tFallState = null; // { falling, pFalling, return }
	field state = null;
	
	constructor() : base() {
	
		this.person = new Sprite(SpriteType.PERSON, SCREEN_WIDTH / 2, GROUND_Y);
		this.person.canHitTest = true;
		
		this.restoreLetters();
	}
	
	function restoreLetters() {
		this.sprites = null;
		
		this.letters.clear();
		
		chars = 'TWOCANS&STRING';
		x = SCREEN_WIDTH / 6;
		modes = [
			Mode.FALLS_DOWN, // T
			Mode.SHIVERS, // W
			Mode.BOMB_EXPLODES, // O
			
			Mode.DRAW_ON_SCREEN, // C
			Mode.RUNS_AROUND, // A
			Mode.PERSON_CHANGES, // N
			Mode.INVERT_COLORS, // S
			
			Mode.NONE, // &
			
			Mode.DONT_GET_BANNED, // S
			Mode.CREDITS, // T
			Mode.SCENERY, // R
			Mode.TODO_IMPLEMENT, // I
			Mode.TOTORO, // N
			Mode.BANNED, // G
		];
		for (i = 0; i < chars.length; ++i) {
			c = chars[i];
			sprite = new Sprite(SpriteType.LETTER, x, LETTERS_Y);
			sprite.letterMode = modes[i];
			sprite.letter = c;
			sprite.canHitTest = c != '&';
			x += SCREEN_WIDTH * 2 / (chars.length * 3);
			if (i == 0) x -= 8;
			if (i == 1) x += 12;
			if (i == 6) x += 8;
			if (c == '&') x += 8;
			if (c == 'I') x -= 16;
			this.letters.add(sprite);
		}
	}
	
	function isModeLocked() {
		// TODO: return true in instances where you want to prevent the user from 
		// progressing to another mode.
		return false;
	}
	
	// previous mode is guaranteed to be over
	function launchMode(mode) {
		switch (this.mode) {
			case Mode.FALLS_DOWN:
				this.tFallState = 'falling';
				break;
				
			case Mode.SHIVERS:
				break;
		}
	}
	
	// each mode is responsible for setting this.mode = Mode.NONE, as it may be asynchronous.
	function endMode() {
		switch (this.mode) {
			case Mode.FALLS_DOWN:
			case Mode.RUNS_AROUND:
				// just wait for it to end.
				break;
				
			case Mode.SHIVERS:
				for (letter : this.letters) {
					letter.renderOffsetXY = null;
				}
				this.mode = Mode.NONE;
				break;
				
				
			default:
				this.mode = Mode.NONE;
				break;
		}
	}
	
	function update(events) {
		
		if (this.mode == Mode.NONE && this.queuedMode != null) {
			this.launchMode(this.queuedMode);
			this.mode = this.queuedMode;
			this.queuedMode = null;
			this.modeCounter = 0;
		}
		
		for (event : events) {
			if (!this.isModeLocked()) {
				if (event.type == EventType.MOUSE_LEFT_DOWN && this.queuedMode == null) {
					sprite = this.hitTestSprites(event.x, event.y);
					if (sprite != null) {
						if (sprite.type == SpriteType.PERSON) {
							Web.launchBrowser('http://twocansandstring.com');
						} else if (sprite.type == SpriteType.LETTER) {
							// clicked the same letter
							if (this.mode == sprite.letterMode) {
								if (this.mode == Mode.NONE) {
									// do nothing
								} else {
									// end this mode.
									this.endMode();
									this.queuedMode = Mode.NONE;
								}
							} else { // clicked another letter
								if (this.mode != Mode.NONE) {
									this.endMode(); // end the current mode
								}
								this.queuedMode = sprite.letterMode; // queue up the next mode.
							}
						}
					}
				}
				
				switch (this.mode) {
					case Mode.SCENERY:
						// TODO: process scenery events
						break;
						
					case Mode.DRAW_ON_SCREEN:
						// TODO: process draw events
						break;
					
					default: break;
				}
			}
		}
		
		if (this.mode != null) {
			switch (this.mode) {
				
				case Mode.FALLS_DOWN:
					
					if (this.tFallState == null) this.tFallState = 'falling';
					switch (this.tFallState) {
						case 'falling':
							if (abs(this.letters[0].y - GROUND_Y) < 10) {
								if (abs((this.letters[0].x - 20) - this.person.x) < 40) {
									this.tFallState = 'pFalling';
									this.person.isFrozen = true;
									this.person.specialMode = null;
								}
							}
							
							this.letters[0].y += 8;
							if (this.letters[0].y > SCREEN_HEIGHT + 100) {
								this.letters[0].y = -100;
								this.tFallState = 'return';
							}
							
							break;
							
						case 'pFalling':
							this.letters[0].y += 12;
							this.person.y += 8;
							if (this.letters[0].y > SCREEN_HEIGHT + 100) {
								this.letters[0].y = -100;
								this.person.y = -100;
								this.tFallState = 'return';
							}
							break;
							
						case 'return':
							this.letters[0].y += 4;
							letterBack = false;
							if (this.letters[0].y > this.letters[0].homeY) {
								this.letters[0].y = this.letters[0].homeY;
								letterBack = true;
							}
							if (this.person.isFrozen) {
								this.person.y += 4;
								if (this.person.y > GROUND_Y) {
									this.person.y = GROUND_Y;
									this.person.isFrozen = false;
								}
							}
							
							if (letterBack && !this.person.isFrozen) {
								this.tFallState = null;
								this.mode = Mode.NONE;
							}
							break;
							
						default:
							assert(false, "Unknown T-Fall state:" + (this.tFallState ?? 'null'));
							break;
					}
					break;
				
				case Mode.RUNS_AROUND:
					activeLetter = this.letters[4];
					if (this.state == null) {
						this.state = 'fall';
					}
					switch (this.state) {
						case 'fall':
							activeLetter.specialMode = 'A-run';
							activeLetter.y += 5;
							if (activeLetter.y > GROUND_Y) {
								activeLetter.y = GROUND_Y;
								this.state = 'run1';
							}
							break;
							
						case 'run1':
							activeLetter.x += 5;
							if (activeLetter.x > SCREEN_WIDTH + 50) {
								activeLetter.x = -30;
								activeLetter.y = LETTERS_Y;
								this.state = 'run2';
							}
							break;
							
						case 'run2':
							activeLetter.x += 5;
							if (activeLetter.x > activeLetter.homeX) {
								activeLetter.x = activeLetter.homeX;
								this.mode = Mode.NONE;
								this.state = null;
								activeLetter.specialMode = null;
							}
							break;
							
						default:
							this.state = null;
							break;
					}
					break;
				
				case Mode.SHIVERS:
					for (i = 0; i < this.letters.length; ++i) {
						letter = this.letters[i];
						if (letter.renderOffsetXY == null) {
							letter.renderOffsetXY = [0, 0];
						}
						
						t = this.modeCounter * Math.PI * 2 / FPS * 5;
						value = floor(Math.sin(t) * 3);
						x = value;
						y = value;
						if (i % 3 == 2) x *= -1;
						if (i % 2 == 1) y *= -1;
						letter.renderOffsetXY[0] = x;
						letter.renderOffsetXY[1] = y;
					}
					break;
			}
		}
		
		for (sprite : this.getAllSprites()) {
			sprite.update(this);
		}
		
		this.modeCounter++;
	}
	
	function hitTestSprites(x, y) {
		for (sprite : this.getAllSprites()) {
			if (sprite.canHitTest && sprite.lastImageBounds != null) {
				bounds = sprite.lastImageBounds;
				if (x > bounds[0] && x < bounds[2] && y > bounds[1] && y < bounds[3]) {
					return sprite;
				}
			}
		}
		return null;
	}
	
	function getAllSprites() {
		if (this.sprites == null) {
			this.sprites = [this.person];
			this.sprites.concat(this.letters);
			this.sprites.concat(this.otherSprites);
		}
		return this.sprites;
	}
	
	function render(rc) {
		GFX.Draw.fill(255, 255, 255);
		
		for (sprite : this.getAllSprites()) {
			sprite.render(rc);
		}
	}
}
