import Math;
import GFX;

enum SpriteType {
	LETTER,
	PERSON,
}

class Sprite {
	
	field type;
	field x;
	field y;
	field letterMode;
	field canHitTest = false;
	field specialMode = null;
	field specialModeCounter = 0;
	field isSleeping = false;
	field isLeftFacing = false;
	field dx = 0;
	field dy = 0;
	field isMoving = false;
	field personFlavor = 'person1';
	field letter;
	field lastImageBounds = null;
	field renderOffsetXY = null;
	field homeX;
	field homeY;
	field isFrozen = false;
	
	static field PERSON_FLAVORS = 'person1 person2 person3 person4'.split(' ');
	
	constructor(type, x, y) {
		this.type = type;
		this.x = x;
		this.y = y;
		this.homeX = x;
		this.homeY = y;
	}
	
	function update(scene) {
		switch (this.type) {
			case SpriteType.PERSON:
				this.updatePerson(scene);
				break;
			case SpriteType.LETTER:
				this.updateLetter(scene);
				break;
		}
		
		if (this.dx != 0) {
			this.isLeftFacing = this.dx < 0;
		}
		
		this.isMoving = this.dx != 0 || this.dy != 0;
		
		this.x += this.dx;
		this.y += this.dy;
		this.dx = 0;
		this.dy = 0;
	}
	
	static field PERSON_MODES = [
		'left',
		'right',
		'left',
		'right',
		'sleep',
		null,
	];
	
	function updateLetter(scene) {
		
	}
	
	function updatePerson(scene) {
		if (this.isFrozen)
			return;
		
		
		if (this.x < -50) this.x = SCREEN_WIDTH + 45;
		if (this.x > SCREEN_WIDTH + 50) this.x = -45;
		
		if (this.specialMode != null) {
			switch (this.specialMode) {
				case 'left':
					this.dx = -3;
					break;
				
				case 'right':
					this.dx = 3;
					break;
					
				case 'sleep':
					this.isSleeping = true;
					break;
			}
		}
		
		if (this.specialModeCounter++ >= FPS * 2) {
			this.isSleeping = false;
			this.changePersonMode();
		}
	}
	
	function changePersonMode() {
		Sprite.PERSON_MODES.shuffle();
		this.specialModeCounter = 0;
		this.specialMode = Sprite.PERSON_MODES[0];
	}
	
	function render(rc) {
		x = floor(this.x);
		y = floor(this.y);
		
		switch (this.type) {
			case SpriteType.PERSON:
				return this.renderPerson(rc, x, y);
			case SpriteType.LETTER:
				return this.renderLetter(rc, x, y);
		}
	}
	
	function renderPerson(rc, x, y) {
		isWalk = this.isMoving && ( (rc / 2) % 2) == 0;
		
		img = ImageLibrary.get('characters/' + this.personFlavor + '_' + (isWalk ? 'stand' : 'walk'), this.isLeftFacing);
		left = x - img.width / 2;
		top = y - img.height;
		img.draw(left, top);
		this.updateBounds(img, left, top);
	}
	
	function renderLetter(rc, x, y) {
		letter = this.letter.lower();
		if (letter == '&') letter = 'amp';
		left = x - 30;
		top = y - 30;
		
		if (this.renderOffsetXY != null) {
			left += this.renderOffsetXY[0];
			top += this.renderOffsetXY[1];
		}
		
		img = ImageLibrary.get('letters/black/' + letter);
		
		if (this.specialMode != null) {
			switch (this.specialMode) {
				case 'A-run':
					img = ImageLibrary.get('letters/black/a_run_' + ((rc / 4) % 2 + 1));
					break;
				default:
					break;
			}
		}
		
		img.draw(left, top);
		this.updateBounds(img, left, top);
	}
	
	function updateBounds(img, left, top) {
		if (this.canHitTest) {
			if (this.lastImageBounds == null) this.lastImageBounds = [0] * 4;
			this.lastImageBounds[0] = left;
			this.lastImageBounds[1] = top;
			this.lastImageBounds[2] = left + img.width;
			this.lastImageBounds[3] = top + img.height;
		}
	}
}